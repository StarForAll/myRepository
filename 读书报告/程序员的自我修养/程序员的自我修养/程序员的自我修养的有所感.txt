书名:程序员的自我修养-链接,装载与库
主要内容:计算机底层机制和运行原理.
目的:知其然,更知其所以然.
程序员需要的修养:
       1.对技术探根究底,探究其封装中的技术细节是如何运行的
       2.对自己感兴趣的技术进行实践
       3.系统底层的学习的必要性
       4.面对艰难处的处理方式
       5.对知识的渴求

导读:
文件:可执行文件(其形成过程,如何装载并执行,与进程的虚拟空间的映射),目标文件(程序代码编译成目标文件,程序在目标文件中的存储,多个目标文件的链接,链接时的处理,链接的方式,如何动态链接,为什么动态链接,如何处理动态链接中出现的问题,重定位和地址分配),堆,栈,运行库,Glibc,MSVC CRT的实现分析,系统调用与API

技术准备:
1.从HELLOWORLD开始
2.计算机硬件:CPU,IO设备,内存.
         多核:多个处理器共享一个缓存
         各层之间是接口使用,硬件和软件的相互独立
         软件获取的接口是从运行库获得(应用程序编程接口),运行库的接口从系统中获得(系统调用接口,软件中断方式获得),系统接口由硬件接口定义(程序驱动硬件)
         
3.操作系统的演变:单道->多道->分时->多任务
4.接口访问的统一性:将一类事物抽象为一种接口(如:图形->GDI)
5.硬件的分级:硬盘->盘片->磁道->扇区(硬件抽象化,使用虚拟空间表示)
  补充:计算机底层是读取:操作码 操作数
6.CPU利用率的提高:逻辑地址空间的隔离,内存空间的合理分配,运行地址的逻辑化(虚拟地址:从0开始),{另:虚拟地址映射到物理地址,中间层的使用,某个映射函数使用}
从逻辑上来看是0H开始的,但是实际上的物理地址是系统映射的,是两两不同的进程占用不同的物理地址空间.
       分段:按照整个程序大小进行内存分配
       分页:页大小固定,将进程中的常用的部分加入到内存中,不常用的就放在磁盘中,但当需要访问时,就将其加入内存中,即进行页面置换(存在有关算法).
        {内存的利用率提高}
        虚拟映射部件:MMU
7.线程(执行的最小单元)
     一个进程由多个线程组成,进程中的某些资源(代码段,数据段,堆),但某些资源是独占(栈,寄存器,局部变量),并发不会互相干扰
     状态:运行,就绪(运行需要的资源就绪,就差CPU),等待(需要其他事件的处理,非CPU处理事件)
     [非]抢占:线程是否能被系统撤销,而非线程自动放弃.
     fork:复制当前进程,共享当前的内存空间;exec():新的进程覆盖当前可执行印象;clone():子进程创建,有选择的共享内存空间(相对于一个线程的产生)
    共享数据访问:作为临界资源(原子操作,加锁,同步)
    加锁中出现的问题:过度优化(相邻的指令执行顺序的互换->造成错误[volatile]),CPU的乱序执行(new对象中包含多个步骤,其中的步骤顺序,CPU可能不会按照其顺序执行[barrier()])
   线程模型:
         一对一:一个用户线程对应一个内核线程(上下文切换消耗大)
         多对一:多个用户线程对应一个内核线程(一个线程的阻塞会阻塞其他线程)
         多对多:多个用户线程对应多个内核线程(一个线程的阻塞不会影响其他的线程)
第2部分(静态链接)
编译和链接(编译和链接的隐藏->Build)
1.预处理(.i文件的生成)->编译(.s文件的生成)->汇编(.o文件的生成)->链接(.o和库文件的链接)
   预编译:将相关的文件(.h和.c文件)转换为.i文件;具体过程是将注释去除,预编译指令的处理(#define宏定义,#include),产生行号.
   编译:将.i文件转换为.s文件,具体操作是词法分析,语法分析,语义分析,代码优化再到汇编代码文件的生成.
      词法分析:
      语法分析:
      语义分析:分析的静态语义,在编译期的;而对应的是动态语义,在运行期的.
   (预编译和编译的操作合并:ccl hello.c)
   汇编:将.s文件转换为.o文件,即转换为机器可以执行的操作语句(如:操作码 操作数)
   链接:将所有的相关的文件和目标文件链接起来(如:库文件和.o文件).多个目标文件链接成一个文件,其中的地址进行重定位,从此之后就确定了一个文件的index,array的地址.
        符号的使用:表示一个变量/子程序/函数的起始地址.
        将程序划分为多个模块,独立处理问题,相互依赖,易于代码的复用和理解.
        模块间的访问问题:函数地址的访问,变量地址的访问,统称为模块间的符号访问.
   经历过程:地址和空间的划分,符号绑定,重定位.
目标文件(.o/.obj文件,其格式和可执行文件的格式相同,只是没有经过重定位)
1.库文件:静态库(.a,.lib),动态库(.so,.dll)
2.ELF格式文件:
         可重定位文件:.o文件,其中包括代码和数据,用来链接形成可执行文件(包括静态库文件).
         可执行文件:就是可以直接运行的程序
         共享目标文件:.so文件(动态库文件);和可重定位文件链接形成新的可重定位文件,或是可执行文件的运行的一部分.
         核心转储文件:将意外终止的进程信息写入到该文件中(如:core dump).
       PE和ELF的先祖是COFF
3.file 文件名:得到这个文件的格式的详细信息.
4.目标文件内容:代码段(机器代码指令),数据段(数据:),链接信息(符号表,调试信息,字符串...),其中的内容以段(segment)的形式存储.[与进程中内容相似]
                文件头:文件的属性信息,段表(各个段的结构信息,一个段描述符对应一个段,其中的第一个段描述符是无效信息)
                代码段:.txt,.code
                数据段(.data):初始化的全局变量,局部静态变量
                BSS段:未初始化的全局变量,局部静态变量.(在本段中没有内容,不会占用空间,只是为这些未初始化的量预留位置)如果初始化变量为0,那么也会存放到本段中.
               只读数据段(.rodata):字符串常量,const修饰的变量
               注释信息段(.comment):编译器版本信息
               调试信息:在对源代码设置断点之后,进行调试,其中就保存着调试过程中的信息.(占用的空间比代码段都要多,strip 文件名:删除其中的调试信息)
               自定义段:用户自己定义的段(如,将MP3转换为.o文件加入到目标文件段中)
       数据段,只读数据段,BSS段:这三者存放的都是data.
       段的名字对于编译器有用(如:.rodata),但对于操作系统来说,没有意义,其段的属性和权限才是对于操作系统有用的信息.
5.代码和数据分离的必要性:
                两者访问的权限不同:前者只读,后者可读可写
                指令缓冲和数据缓冲的分离有利于缓存的命中率
                代码段的共享,即指令的共享,可以在不同的进程中,只是其中的数据不同而已.
6.使用objdump查看.o文件中的内容(如objdump -h simpleSeesion.o)
7.符号(函数和变量的统称):在一个目标文件中引用了另一个目标文件中的函数/变量,函数名/变量名->符号名,在不同目标文件中都有一个符号表,其中记载着引用的符号及其地址其中的第一个符号是无效的.
       特殊符号:无需自己定义,直接使用.
       符号名重复防止:自定义的符号名和已有的符号名产生冲突(函数重载),在其前面加上_,也可以是符号修饰,函数签名(识别不同的函数,不论函数名是否相同).符号名是在对应的函数/变量进行修饰之后得到的.
      强符号/弱符号:
                链接在一起的.o文件不能有相同名的强符号(不能重复定义)
                一个符号在一个.o文件中强符号,在其他的.o文件中是弱符号,那么这个符号就是强符号
               如果一个符号在所有的.o文件中都是弱符号,选择哪个占用空间最大的(弱符号可以在多个.o文件中存在,因为内存空间大小是不确定的,无法进行分配,所以将其放在BSS段中,在链接之后大小确定).未初始化的全局变量是弱符号,但是可以人为的设置(不以common块形式处理),成为一个强符号.
       两者用于链接的过程.
静态链接(将两个目标文件链接成一个文件[是合并的过程])
1.类似段合并:每个.o文件都有相同的段,将相同名段进行合并.
                            这个合并过程中,进行空间的分配(虚拟地址空间和可执行文件空间的分配),其中的BSS段就只是分配虚拟地址空间的分配.
2.链接过程:
              地址和空间的分配:段的合并,全局符号表的建立
              符号解析和重定位:在一个.o文件中使用另一个.o文件的符号(确定是否有对应的符号定义),代码地址的调整
3.链接命令:ld a.o b.o -e main -o ab (ld a.o b.o:链接两个.o文件,-e main:以main为程序入口(默认是_start),-o ab:生成的文件名为ab)
4.重复代码的去重:
        产生原因:在不同的编译单元(模板,外部内联函数,虚函数表)中产生相同的代码
       做法:将其存放到单独的段中,如果有其他的实例化函数出现,就会是相同的名称(相同的段名称可能有不同的代码,代码的优化/不同的编译器编译,编译器会选择其中一条作为链接的输出).
5.函数级别链接:在需要某个.o文件中的函数时,会将整个文件加载进去,而函数极链接会将需要的函数加载进去而非整个文件.
6.程序执行过程(Linux):程序初始化(入口:_start)->main中执行->返回初始化部分,进行清除工作.
            初始化代码:存放到.init中,只要是在这个段中指令,那么都会在main前执行.
7.不同编译器编译产生的目标文件进行链接:不同的编译器能识别对方的格式(windows是PE,Linux是ELF)是对链接,没有用的.
                        1.产生的目标文件格式相同
                        2.符号修饰方式,变量存储方式,函数的调用方式相同(即ABI[可执行二进制代码中兼容性相关的内容]相同).
                                          ABI:二进制层面的接口,ABI的统一还未解决.
8.静态库链接:
       大部分库函数API是对系统库函数API的封装使用.
        静态库文件:许多目标文件的集合组成.他们之间是相互依赖,是你中有我,我中有你的情况.所以不可能将其中的一个.o文件拿出来和对应的目标文件进行链接,那样可能会产生未定义符号的错误.(如:在一个简单的HelloWord中,其printf使用的是stdio中的printf.o文件中的内容,但是单独和printf.o进行链接就会出现未定义符号:stdout,vfprintf).其中每一个.o文件都只是包含一个函数.(原因是在ld链接器进行链接时会自动选择所需要的.o文件进行链接,而如果其中的.o文件不仅仅只是包含这一个函数,那么就会占用多余的空间,在最终的可执行文件中就没有必要占用空间)
        在进行库与目标文件链接的时候,ld链接器会将库中所有需要的.o文件取出进行链接而不是将这个库中所有的.o文件进行链接,当然了在这其中还需要一些辅助性质的库和目标文件参与.
9.链接过程控制:
           在一般情况下,链接是将对应的目标文件进行链接,但存在一些特殊情况(操作系统内核程序,没有系统的程序),自己在.c文件中编写汇编代码(不使用库文件)
          ld链接脚本:不需要在命令中进行段的设置,只要在其中进行描述,然后再执行这个脚本即可.
                语法:ENTRY(symbol),指定这个symbol为程序入口;
          最小的ELF可执行文件大小是45个字节,是以42为进程退出码正常退出程序
10.BFD库:存在着不同的目标文件格式,统一的接口处理不同格式的目标文件;在其中设计统一的模型;gcc(GNU汇编器,GNU Assembler),链接器ld,调试器GDB都是通过BFD库间接处理目标文件,这样做的好处就是在之后出现了新的目标文件格式就可以将其添加到BFD库中,而不需要改动gcc等.

Windows PE/COFF
1.PE:Windows下的标准可执行文件格式,能在不同的Windows下运行,其前身是COFF,允许将函数放在自定义段中.
        映像:因为PE文件被直接映射到进程的虚拟空间中运行.
2.COFF:和ELF文件内容类似.
        映像头(ELF文件中的文件头),段表(描述每个段的属性:段名,物理地址,虚拟地址,大小,段在文件中的位置,段的重定位表在文件中的位置,段的行号表在文件中的位置)
3.PE和COFF的区别:
            在目标文件开始部分是DOS MZ可执行文件的头文件和桩代码.
            PE文件头中不仅仅包括了原来COFF中的映像头,还有新增的PE扩展头部结构
4.PE数据目录:
          将常用的数据结构的位置(虚拟地址)和长度存储到其中.

第3部分(装载与动态链接):

可执行文件的装载与进程
1.进程虚拟空间:
        大小与计算机位数有关,32位:0H-FFFFFFFFH(即4GB),64位:0H-FFFFFFFFFFFFFFFFH(17179869184GB).指针的大小也与位数有关,32位:4个字节,64位:8个字节.
        当然了,这只是假设的大小,实际的物理内存分配没有这么大.而且不同的虚拟地址区间是有系统权限限制的,不能随便访问.(如果访问了这些地址,就会被系统视为非法操作,立刻结束进程)
2.虚拟空间分配:
        0H-BFFFFFFFH:系统使用(1GB)
        剩下的地址空间理论上属于用户使用的.
3.PAE:
      在32位下,只能使用4G的虚拟地址空间(只能访问到0-4GB的地址范围)
               地址扩展方式(页映射方式,可以访问更多的内存)
        操作系统提供一个窗口映射的方法,将额外的内存空间映射到进程地址空间中.
     这仅仅是非常规手段,不能长久使用,正常的使用应该是使用位数更高的系统和CPU.
4.装载:
          动态:将程序中经常使用的部分加载到内存中,不常使用的部分依旧存放到磁盘中.这样做能够有效地提高内存的利用率,能够让更多的程序进驻内存.[小内存运行大程序]
     动态装载方法1(覆盖装入):现在几乎已淘汰,人为的将程序划分了几块,然后利用覆盖管理器来进行管理何时进行驻留内存,何时换出内存.  块的换出和换进虽然提高了内存的利用率,但这是时间换空间的做法.
     动态装载方法2(页映射):虚存技术的一部分,将内存的基本单位划分为页,将磁盘中的程序也划分为页,其页号和内存中的页号进行对应,装载管理器根据实际进程运行的情况来进行页面的分配.
5.进程执行前:
        创建一个虚存空间
        读取可执行文件头,虚存空间和程序产生映射关系.
        将CPU寄存器作为程序开始执行的入口.(将CPU寄存器控制器转让给进程)
6.页错误的出现:就是虚存中页面为空/或者是没有读到所需要的页面,就会产生,操作系统会进行相应的物理页分配.
7.进程虚存空间分布:
              在进行页分配的时候,可能出现页分配有浪费的情况(页内碎片的产生),操作系统需要将相同权限(可读,可写)的段一起进行映射.
            程序头表:类似目标文件中的段表,存储着其中的segment的属性信息
            代码VMA:只读可执行,有映像文件
            数据VMA:可读可写,有映像文件,其中的.bss段是属于其的,但是其无映像文件,所以将其划分到堆VMA中.
            堆VMA:系统为进程分配的内存空间,malloc分配到的内存就是来自于堆,可读写可执行,无映像文件
            栈VMA:可读不可执行,无映射文件.其中保存系统变量,和进程运行参数.在程序运行中,栈会把信息传递到main中,即argc,argv
8.段对齐:解决页面内碎片的产生,将一个页面未使用部分让另一个段进行使用;这样的的话,段对应的虚拟地址就不会是页的整数倍,但内存利用率提高.
9.ELF文件的装载
10.PE文件的装载

Linux下的动态链接
1.动态链接的必要性:静态链接的内存利用率不高,存在重复库,一次性将所有放入内存.静态链接形成的可执行文件是一体的,如果其中的库文件进行更新,那么会很麻烦.
2.动态链接的基本思想:链接文件是在程序运行的时候进行,而不是在形成可执行文件前,如果内存中已经有对应的库文件[进程共享模块],那么就不需要在往内存中添加对应的库文件.进行链接工作的是动态链接器,当然了,会有一些性能上损失,是时间换空间的做法.
  普通共享文件和动态链接器和可执行文件都会映射到虚存中去.
3.共享文件地址的确定:
           确保不会有影响:多个共享模块间地址不会起冲突,共享模块升级之后大小变化不会影响到其他模块空间地址.
           方法:在编译是不能假设在进程中虚存的位置(可以在任意位置加载).
4.装载时重定位:
          将编译器地址不确定的模块在装载时进行地址重定位.
         缺点:不能在进程间进行模块共享
5.地址无关代码(PIC):将程序指令中那些需要修改的部分拿出来和数据部分放在一起,就不会因有装载时地址的变化.
      类型划分:
                模块内调用/跳转:调用者和调用函数在同一个模块中,两者的相对位置是确定的,那么调用指令就是相对位移调用指令,其指令的执行和这个模块的地址是无关的.
                模块内数据访问:一个模块内前面是数个代码也,后面是数据页,就是说代码指令位置和数据的相对位置是确定的. 
                模块间调用/跳转:在GOT中保存的是目标函数的地址,通过GOT间接访问其他模块的指令
                模块间数据访问:在数据段中建立一个全局偏移表GOT(全局变量...)[指向这些变量的指针数组],当代码需要引用这些全局变量时就通过GOT间接访问这些变量.
         模块内是相对访问,模块间是间接访问.
         区分动态链接库是否为PIC: readelf -d xxx.so | grep TEXTREL
6.对于共享库中的全局变量的使用:
                  在进程间来说,其全局变量的变化,不会影响到其他进程的这个变量,因为不同的进程是拥有不同的数据副本,是相互独立的.
                  在线程间来说,这个全局变量是共享的,其值的变化是会影响到其他线程使用这个变量的.
7.延迟绑定:
           动态链接比起静态链接要慢一些(性能降低),就是需要进行复杂的GOT的定位,还有一个原因就是程序在执行的时候进行链接.
           这是一种优化动态链接的方法.
           很多功能是很少使用,也有可能是不使用,这就要意味着在运行时将全部的模块进行链接是不划算的,所以说就需要在之后进行绑定(延后,直到该模块执行时进行绑定), 
           实现方式:PLT
8.动态链接相关结构:
            .interp段:保存动态链接器的路径.
            .dynamic段:保存着动态链接器所需要的基本信息(共享对象的位置,动态链接符号表的位置,动态链接重定位表的位置).
            动态符号表
            动态链接重定位表
9.动态链接的步骤:
          动态链接器的启动->共享对象的装载->重定位和初始化

Linux共享库的管理
1.共享库:
         兼容性:和程序是分开开发,但共享库的版本升级可能会造成不兼容的问题,接口产生了变化.减少接口(ABI)变化的可能操作.
           兼容性更新/不兼容性更新:接口是否变化(ABI)
        共享库版本命名:libname.so.x.y.z:x是指主版本号,一个大版本的更新,主版本号之间的接口是不兼容的;y是指次版本号,增加了一些接口,z是指发布版本号修复了一些bug,性能的改进
        SO-NAME命名机制:共享库的依赖关系,去除次版本号和发布版本号,保留主版本号.共享库管理程序会产生一个对应的软链接,如果有新的版本,它就会链接这个主版本的最新版本(永远指向的是最新的).
       ldconfig:遍历所有的共享库软链接,更新所有的软链接,如果有新的软链接就进行增加
       次版本交会问题
2.符号版本
3.共享库系统路径
               遵循FHS标准,FHS规定了系统文件的存储路径.(/lib:系统关键基础共享库,/usr/lib:非系统运行关键共享库,/usr/local/lib:与操作系统不相关的库文件(第三方库),/usr/local/bin)
        共享库查找:在.dynamic段中有对应的地址(相对路径/绝对路径),一般是相对路径.ldconfig会将所有的SO-NAME放到一个文件(/etc/ld.so/cache)中,要查找就在这个文件中查找.如果没有在这个文件中找到,就会遍历/lib和/usr/lib,如果还没找到,就会报错
   环境变量:
        LD_LIBRARY_PATH的使用:动态链接是首先会在这个路径下查找对应的共享库文件,临时改变某个程序查找共享库的顺序,不影响其他程序.不能滥用,如果这个环境变量设置为全局变量,会造成其他程序查找共享库的顺序.
       LD_PRELOAD:这个环境变量的使用会将其路径中的共享库在搜索共享库前装载,不论是否在程序运行时使用,优先级高于LD_LIBRARY_PATH
       LD_DEBUG:打印各种有用信息
4.共享库的创建
         指令:gcc -shared -fPIC -WI,-soname,my_soname -o libraryName sourceFiles(.c源代码文件) -libraryName(要使用的共享库名)
         -shared:输出共享类型文件.
         -fPIC:使用地址无关代码技术来输出这个文件
         -WI,-soname,my_soname:使用SO_NAME生成my_name软链接
       清除共享库中的调试信息:在生成最终的库之后,这些调试信息就无用,还会占用许多的空间.strip xxx.so
5.共享库的安装
        让自己创建的共享库能想系统共享库一样被程序访问.
        方法:
              将创建好的共享库文件移动到/lib或/usr/lib中,然后运行ldconfig
              ldconfig指定这个共享库的路径,而且在gcc编译程序的时候也要说明共享库的路径
6.共享库构造和析构函数:
              在函数声明上加上_attribute_((constructor(num))):构造函数,该共享库在加载是就会运行,在main之前.num为优先级,越小越先执行.
                                        _attribute_((destructor)):析构函数,在main函数执行完毕之后运行

Windows下的动态链接
1.动态链接库(DLL):相对于Linux下的共享对象,和exe是相同格式(PE格式的二进制文件)的文件,后者有.dll,.ocx
                   Windows下的软件更新包就是更新一些dll文件
           内容:
                   文件头(Image Base):基地址(进程空间的起始地址),相对地址:就是相对于基地址的偏移量
                   共享数据段:DLL中有所有进程共享的数据段,也有一个进程私有的数据段,所有这个共享的数据段可以实现进程间的通信.(这种通信不安全)
       创建DLL:
                   __declspec(dllexport):函数修饰符,表示这个函数是从本DLL中导出
                   __declspec(dllimport):函数修饰符,表示这个函数是从别的DLL中导入
              在创建对应的.c源代码文件之后,就需要使用指令:cl /LDd DLL名.c(LD可以不加d,加上d表示是debug版本的DLL)->DLL名.lib,DLL名.obj,DLL名.exp,DLL名.dll
            DLL名.lib:便于程序与DLL.dll进行连接
        使用DLL:
             方法:a)在使用这个DLL文件的源代码中进行说明要引用的函数:__declspec(dllimport) 函数名(参数列表);
                    在进行编译时的指令:cl /c 程序.c 
                                        link 程序名.obj DLL名.lib ->程序.exe
                     b)不在DLL的源程序中中写__declspec(dllexport),而是编写一个.def文件,提供导出符号(即相关的函数或其他)
                              LIBRARY DLL名
                              EXPORTS
                              符号.......
                         编译指令:cl 程序.c /LD /DEF def文件名.def
           运行时链接:需要在程序中使用这些函数
                                                              LoadLibrary("DLL名.dll"):装载DLL到进程中的地址空间
                                                              GetProcAddress(HINSTANCE对象,"函数名"):查询某个符号的地址
                                                              FreeLibrary(HINSTANCE对象):动态卸载某个已经加装的模块
2.符号导出导入表
             符号导出:将一个PE中的内容(函数/变量)提供给其他PE文件使用
             导出表:将所有导出的符号写入其中,每一个导出的函数都有一个唯一的序号.
             EXP文件的产生:在创建DLL文件是,第一次编译会将导出表放到一个临时的文件中,第二次就会将这个导出表放到DLL文件中.所以说,这个文件就是一个临时性的文件.
             符号导入:程序中使用了来自DLL中的函数/变量
             导入表:将所有需要导入的函数地址确定
3.DLL优化:
      原因:
            数据段和代码段不是地址无关的,会需要进行rebase,大量的rebase会减慢程序启动速度.
            导入导出符号的过程占用很多时间
      方法:
          重定基地址
          改变基地址
          使用导出函数的序号(对于Windows中的DLL不要使用序号,因为他们的序号在不断的变化)
          导入函数绑定:将这些导出函数的地址保存到模块的导入表中
4.DLL HELL
               版本更新时不兼容
           解决办法:
                   静态链接:在编译程序的时候使用静态链接
                   防止DLL覆盖:阻止未授权的DLL覆盖系统的DLL
                   避免DLL冲突:将各个程序所需要的DLL文件放在本程序的文件夹下,不同的程序可以使用自己所需要版本的DLL

第4部分(库与运行库)
内存
1.程序在内存中的布局
            系统使用部分(1GB)
            栈:函数内部的变量,参数等函数相关的变量,维护函数的上下文
            堆:malloc,new得到内存空间就存储在堆中,存储动态分配的内存空间
            可执行文件映像:可执行文件在内存中的映像
            保留区:受到保护禁止访问的内存区域(如:NULL)
2.栈
          特性:向下增长,先进后出,动态数据操作,栈顶(第一个进栈的数据的地址,再不断的变化)由ESP寄存器确定
          内容:
                   参数和返回值
                   临时变量
                   上下文:在函数调用前面不变的寄存器信息(ESP,EBP)
          调用惯例:所有函数调用的方式相同(如:参数入栈是左边的参数先入,右边的后入栈)
          返回值是通过eax寄存器获得,如果是大于4个字节的返回值,会通过return_test()函数将这个返回值移动到对应的地址
3.堆
       动态申请的内存空间,可能大也可能小.在程序主动放弃前一直有效(free()).
        在程序运行前就要获取足够大的空间,然后程序的运行库进行堆空间的分配.
         堆空间分配:
             brk():设置数据段的结束地址
             mmap():想系统申请虚拟空间,在不进行文件映射是,就可以作为堆空间了.
        malloc():在申请的空间小于128KB时,直接分配存在的堆空间,如果空间大于128KB就使用mmap()再申请一块新的虚存空间.
      一个进程可能存在着多个堆空间,因为一个堆在不能继续进行堆空间扩展时,就会产生新的堆.
     堆分配算法(合理有效的进行堆的分配):
            空闲链表:将堆中空闲的空间连接在一起,当有新的空间申请时,就划分一块合适大小的空间出去,当释放空间时就继续将其合并到空闲链表当中.
            位图:将堆划分为多个块,需要空间时将整数倍的块分配给用户.分配给用户使用的区域的第一块是头(head),其余的是主体(块有三种状态:头,主体,空闲),有碎片产生的可能.
            对象池:每一次分配的大小是固定的,每次请求就只要分配一块

运行库
1.入口函数和程序初始化:MSVC(Windows下的编译器)
                      main不是第一个执行的函数/操作,在此之前会有其他操作(.init段先于main执行);堆栈的初始化,全局变量的初始化.
                      atexit(...);这个函数的操作是在main执行结束之后,所以不论其在main中的哪个位置,都是最后的.
                      glibc中的程序入口是_start,在汇编中可以实现->用户参数,环境变量压栈,调用_libc_start_main()函数
                      _libc_start_main()的内部细节:main,(argc,argv[变化环境变量]),三个指针(init,fini,rtdl_fini),stack_end表名栈底地址(最大地址)
                     _start->_libc_start_main->exit->_exit(_exit中hlt:检测exit系统调用是否成功,调用失败,hlt就会强制程序结束)
                    Windows下的入口函数:
                                  mainCRTStartup(void):初始化OS和版本有关的全局变量->初始化堆->初始化IO->获取命令行参数和环境变量参数->初始化c库中的一些数据->调用main,记录返回值
                   ->检查错误和将返回值返回.
                   初始化:堆初始化(_heap_init()的调用)和IO初始化(FILE文件描述符,文件表)[工作是构造一个打开文件表,_ioinit()的调用]
2.运行库(glibc:Linux系统底层API)
            CRT:程序在运行时所需要的库文件
           运行库所包含的功能:程序启动和退出,IO,标准函数,语言实现,堆,调试     
           标准库是基础函数库       
                        不定参数的传递
                        非局部跳转
          标准库是和平台(操作系统)相关的,生成相同的c标准库,但底层具体是实现细节是不同的.
          组成:头文件和二进制文件
3.多线程
             线程私有:局部变量,函数参数,TLS(线程局部存储)[栈,寄存器,TLS]       
             线程共享:全局变量,局部静态变量,堆中数据,代码段,打开文件(FILE文件描述符)      
             线程相关的库文件是标准库文件之外的系统相关库文件
                    具体操作:
                           操作接口提供(创建,退出,设置优先级)
                           在环境的正确运行:在CRT的设计之初是没有支持多线程的运行的,很多库函数的使用是线程不安全的(如:printf输出显示的信息可能是混乱的)  
                           改进方法:
                               使用线程安全的函数
                               加锁      
                               将线程不安全的函数改进为线程安全的
4.C++全局构造与析构
                _start->_libc_start_main->_libc_csu_init->_init->_do_global_ctors_aux
                _init函数由所有的目标文件中的.init段组成               
                在程序结束前进行对象的析构,析构的过程和前面的构造过程是一样的     
5.IO实现
             fread:C标准库内容,使用了系统API中的函数,是进一步的函数封装
             fflush():flush文件缓冲[将写缓冲中的内容数据写入文件中,清空缓冲]
             setvbuf():设置缓冲方式(无/行/全缓冲)
             缓冲:
             fread->fread_s->fread_nolocak_s-> _read->readFile
            fread_s:缓冲溢出保护,文件加锁,防止多线程读取
            fread_nolocak_s:进行真正的读取文件操作
            _stream->_cnt=_read(_fileno(stream),stream->_base,stream->bufsiz);
            _read:从文件中读取内容;对文本模式打开的文件,转换回车符

系统调用与API
1.系统调用
            程序与操作系统之间的接口,其上层就是系统API;在将许多操作交给系统去做,而不是程序去做,程序没有这个权限,也不能,因为一旦程序能自由操作这些资源,程序访问就会出现冲突.
            将系统自己可以做的事情封装成一个个事件,并将接口放在系统调用中.在Windows中API是程序的终极接口.
            弊端:
                直接使用不方便,一般使用进行了包装的标准库中的函数
                不同版本的系统调用是不兼容的,而标准库是在不同平台上是统一的接口(实现细节是不同的),就是在不同平台上没有可移植性
           权限分级:用户态/内核态,不同权限的可操作的内容范围是不同的.一般程序是运行在用户态的,而系统调用是运行在内核态上的.
           权限切换:通过中断方式进行;
           切换细节:触发中断->切换堆栈->中断处理程序
          Windows使用API的原因:系统更新时,系统调用的接口产生变化,而不会影响到API(不变),做到了旧的程序在新的系统上也可以运行.
2.API
        系统调用封装之后的程序调用接口
 
运行库实现
1.自制C的CRT的要求
              与标准库的接口一致
              能在不同平台上运行(Windows/Linux)
              能对堆栈操作
              有入口函数,支持对文件/字符串操作     
              基本的进程操作
              支持atexit(),格式化的输出操作(printf)  
              实现简单
2.实现步骤
          入口函数(main参数获取;CRT初始化;结束:atexit调用,结束进程)
          堆的实现(堆大小固定,基础的堆空间分配算法实现malloc,free)
          IO与文件操作(实现对文件的基本操作:fread,fopen,fwrite,fcloes,fseek)
          字符串相关操作(计算字符串长度,比较两个字符串,整数与字符串的转换):纯粹用户态操作,不涉及内核操作
          格式化字符串(printf:参数不定,变长参数)
3.使用
         建立头文件,include头文件来使用
         链接生成对应的库文件
         在实例中使用
4.C++运行库的实现
          
gcc/ld/objdump指令的使用