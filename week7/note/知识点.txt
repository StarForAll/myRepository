
标准I/O与系统I/O的关系:
将系统I/O的API进行封装,得到对应C语言中的标准I/O库文件;
系统I/O是在具有可移植性的,而标准I/O只能在有C语言库的系统上执行.
系统I/O中的函数:open,read,write

最基本的判断:使用系统函数是系统IO对应的缓冲方式:无缓冲方式.
系统缓冲I/O:不带缓冲的无缓冲方式.
标准I/O不直接读/写外设,而是使用内存中的缓冲,当满足缓冲条件时,才对外设进行I/O操作.基于系统I/O,进行了封装:
                全缓冲(输出的默认方式):在缓冲区满了之后进行I/O操作,或者是在程序正常结束之后进行,而程序非正常结束不会进行.
                行缓冲:遇到换行符是进行IO操作.
                无缓冲(类似系统I/O方式使用文件[立即]):输入的默认方式(标准出错流stderr).

将其输出重定向到文件: ./lineBuffer>line.dat (覆盖重定向),是全缓冲方式,改变了其中的行缓冲方式.

write(STDOUT_FILENO, buf, sizeof(buf):其中说明是buf中的内容输出到stdout的文件描述符对应的地方,在其他文件没有使用stdout的文件描述符的情况下,就是在终端进行输出显示,类似printf的效果.
但缓冲方式有着明显的不同,使用上面的write进行显示,其方式是系统IO的无缓冲方式;
而printf的缓冲方式一般就全/行缓存两种,两者存在明显不同.

在fork()创建子进程的时候,其子进程使用的代码和父进程系统,但是两者的数据空间不同;因为是两个进程,是对应两个不同的栈空间,所以其数据也就有可能不同.

每个程序打开一个文件,这个文件就会产生一个文件描述符,不同的程序打开相同的文件也会是有不同的文件描述符,即一个文件可以有多个文件描述符.
