对于32位系统,操作系统为每个进程分配了4GB的逻辑地址空间,1G为系统调用空间,其他3G是用户程序使用.

code+PCB(进程唯一标识)+IO设备(逻辑设备号+物理设备号)+内存(内存映射表)+CPU(某时刻CPU)

ELF格式:目标文件和可执行文件的文件储存格式.
    段表及段(Section):
      代码段
      数据段
      BSS段
      符号表段
    ELF头

对于用户来说,物理地址是不可见的,是操作系统进行分配,用户影响的是线性地址.
这样来说,逻辑地址是连续存放的,而与之对应的物理地址就不一定一一对应.

进程使用空间:
           系统空间:系统区
           用户区:栈,堆,BSS段,数据段,代码段
地址从低到高:
          1.保留区
          2.代码段(text):编译成低级语言的代码(机器语言代码).其中的格式:操作码+操作对象(立即数/具备变量的地址引用).
                         不可修改,只读.
          3.数据段(data):已经初始化且不为0的全局变量/静态局部变量,存在对应的物理快.可读可写.
          4.BSS区:未初始化的全局变量/静态局部变量,初始化为0的全局/静态局部变量,未定义且初值不为0的符号.不占用物理空间.
          5.堆:malloc()/new()进行内存的分配,free()/delete()是释放内存空间.内存空间的一般是由程序进行释放的,如果不进行这样                的操作,系统会自动释放.内存空间可以扩展,brk()/sbrk()进行sysbrk的移动,堆空间的扩大.
          6.内存映射区:将硬盘中的文件映射到内存中,可以是映射到此的动态链接库.
          7.栈:非静态局部变量,函数信息(返回值地址,函数入参),临时存储区.栈是每个线程独有的,不是共享的.
          8.系统调用(内核空间):不允许用户操作使用,用户代码不可见,系统程序使用.

进程在内存的使用(32位):开始的地址不是0000H,而是08048000H,那么就存在部分空间浪费(保留区);
64位:00400000H
            原因:
不允许用户自己使用0-08048000H之间的空间(否则会出现Segmetaion Fault),这段空间没有映射到物理空间中.


获取函数中的数据:
               1.全局变量
               2.参数的引用调用
               3.返回值

/proc目录:
        虚拟文件系统,其内文件称为虚拟文件.

编译过程:
       1.词法分析
       2.语法分析
       3.语义分析和中间代码生成
       4.优化
       5.目标代码的生成(高级语言->低级语言)

getpid():获得本进程唯一标识,进程号
getppid():获得本进程的父进程的进程号

编译器:gcc(包含库文件),msvc(windows);

程序错误:
     1.静态错误:编译中产生的错误
     2.运行时错误:地址访问错误,地址空间不足.

BIOS,MMU

线性地址->伪线性地址(地址随机).


最小资源占用进程:srdin(输入),stdout(屏幕),stdio(屏幕).
守护进程/后台进程/前台运行进程
